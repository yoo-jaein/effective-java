# Chapter 12 직렬화

## 아이템 85. 자바 직렬화의 대안을 찾으라
> **핵심 정리**  
> 직렬화는 위험하니 피해야 한다. 시스템을 처음 설계한다면 JSON이나 프로토콜 버퍼 같은 대안을 사용하자. 신뢰할 수 없는 데이터는 역직렬화하지 말자. 꼭 해야 한다면 객체 역직렬화 필터링을 사용하되, 이마저도 모든 공격을 막아줄 수는 없음을 기억하자.

### 직렬화
직렬화란 객체를 바이트 스트림으로 인코딩하는 것이고, 역직렬화란 바이트 스트림으로부터 다시 객체를 재구성하는 것이다. 직렬화된 객체는 다른 VM에 전송하거나 디스크에 저장한 후 나중에 역직렬화될 수 있다.  

### 직렬화의 보안 위험성
직렬화는 보안 문제가 있다. ObjectInputStream의 readObject()를 호출하면 객체 그래프가 역직렬화 되는데, 클래스패스에서 Serializable을 구현한 거의 모든 타입의 객체를 만들어낼 수 있다. 바이트 스트림을 역직렬화하는 과정에서 readObject()가 그 타입들 안의 모든 코드를 수행할 수 있다. 즉, 그 타입들의 코드 전체가 공격 범위에 들어간다. 역직렬화 과정에서 호출되어 잠재적으로 위험한 동작을 수행하는 메서드들을 가젯(gadget)이라 부른다.

### 직렬화의 위험 피하기
1. 아무것도 역직렬화하지 않는다.
2. 직렬화 대신 JSON이나 프로토콜 버퍼를 사용한다.
   - JSON : 브라우저와 서버의 통신용으로 설계된 데이터 표현. 초기에는 자바스크립트용으로 만들어졌다. 텍스트 기반이라 사람이 읽을 수 있다.
   - 프로토콜 버퍼 : 구글이 서버 사이에 데이터를 교환하고 저장하기 위해 설계된 데이터 표현. 초기에는 C++용으로 만들어졌다. 이진 표현이라 효율이 높고 문서를 위한 스키마를 포함하고 있다. 이진 표현뿐만 아니라 사람이 읽을 수 있는 텍스트 표현(pbtxt)도 지원한다.
3. 직렬화를 완전히 배제할 수 없다면 신뢰할 수 없는 데이터는 절대 역직렬화하지 않는다.  
   - ObjectInputFilter를 이용해서 데이터스트림을 역직렬화하기 전에 필터를 설치한다. 특정 클래스를 받아들이거나 거부할 수 있다. 블랙리스트 방식보다는 화이트리스트 방식을 사용하는 것이 좋다.

---

## 아이템 86. Serializable을 구현할지는 신중히 결정하라
> **핵심 정리**  
> Serializable은 구현한다고 선언하기는 아주 쉽지만 신중하게 결정해야 한다.

### Serializable
어떤 클래스의 인스턴스를 직렬화 가능하게 만들려면 클래스 선언에 implements Serializable만 붙이면 된다. 그러나 다음과 같은 주의점을 잘 생각하고 구현해야 한다.  

### 주의할 점
1. Serializable을 구현하면 릴리즈한 뒤에는 수정하기 어렵다. 그 클래스가 직렬화된 바이트 스트림도 하나의 공개 API가 된다. 그래서 이 클래스가 널리 퍼진다면 그 직렬화 형태도 영원히 지원해야 한다. 뒤늦게 클래스 내부를 수정하면 원래의 직렬화 형태와 달라진다. 
2. serialVersionUID 값이 변경될 위험이 있다. 모든 직렬화된 클래스는 serialVersionUID라는 static final long 필드를 부여받는다. 이 번호를 클래스 내에 명시하지 않으면 시스템이 런타임에 SHA-1를 적용해 자동으로 클래스 안에 생성해 넣는다. 이 값을 생성할 때 클래스 이름, 구현한 인터페이스, 대부분의 클래스 멤버들이 고려된다. 그래서 나중에 메서드가 추가되어 수정이 일어나면 UID 값도 변한다. 
3. 버그와 보안 구멍이 생길 위험이 있다. 객체는 생성자를 사용해 만드는 게 기본이다. 역직렬화는 생성자를 우회하는 객체 생성 기법이기 때문에 불변식 깨짐이나 허가되지 않은 접근에 쉽게 노출된다.
4. 해당 클래스의 신버전을 릴리즈할 때 테스트할 것이 늘어난다. 직렬화 가능 클래스가 수정되면 신버전 인스턴스를 직렬화한 후 구버전으로 역직렬화할 수 있는지, 그 반대도 가능한지 검사해야 한다.

---

## 아이템 87. 커스텀 직렬화 형태를 고려해보라
> **핵심 정리**
> 클래스를 직렬화하기로 했다면 어떤 직렬화 형태를 사용할지 고민해봐야 한다. 기본 직렬화 형태는 객체를 직렬화한 결과가 해당 객체의 논리적 표현에 부합할 때만 사용하고, 그렇지 않으면 커스텀 직렬화 형태를 고안하라.

### 기본 직렬화
기본 직렬화라는 것은 Serializable을 구현하기만 하는 것이다.

### 커스텀 직렬화
커스텀 직렬화라는 것은 Serializable을 구현하고 직렬화, 역직렬화를 위한 메서드를 구현하는 것이다. 

```java
import java.io.IOException;
import java.util.Map;

public final class StringList implements Serializable {
   private transient int size = 0;
   private transient Entry head = null;

   private static class Entry {
      String data;
      Entry next;
      Entry previous;
   }

   public final void add(String s) { ...}

   private void writeObject(ObjectOutputStream s) throws IOException {
	   s.defaultWriteObject();
	   s.writeInt(size);
	   
	   for (Entry e = head; e != null; e = e.next) 
		   s.writeObject(e.data);
   }
   
   private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException {
	   s.defaultReadObject();
	   int numElements = s.readInt();
	   
	   for (int i = 0; i < numElements; i++) 
		   add((String) s.readObject());
   }
   //...
}
```
위 클래스는 논리적으로 일련의 문자열을 표현하는데, 물리적으로는 문자열들을 이중 연결 리스트로 연결했다. 이 클래스에 기본 직렬화 형태를 사용하면 각 노드의 양방향 연결 정보를 포함해 모든 Entry를 기록한다. 그렇게 되면 너무 많은 시간, 공간을 소비할 수 있고 스택 오버플로를 일으킬 위험도 있다. 1000~1800개 정도 원소를 담으면 직렬화 과정에서 StackOverflowError가 발생한다. 따라서 클래스의 물리적 표현과 논리적 표현의 차이가 클 때, 커스텀 직렬화를 사용하는 것이 좋다. 물리적인 표현은 배제하고 논리적인 구조만 직렬화하면 된다.  

추가적으로 어떤 직렬화 형태를 택하든 직렬화 가능 클래스에는 serialVersionUID를 명시적으로 부여하는 것이 좋다. 잠재적인 호환성 문제를 해결할 수 있으며, 런타임에 값을 계산할 필요가 없기 때문에 성능도 조금 빨라진다. 이 serialVersionUID는 구버전으로 직렬화된 인스턴스들과의 호환성을 끊으려는 경우를 제외하고는 수정하지 말아야 한다.

---

## 아이템 88. readObject 메서드는 방어적으로 작성하라
> **핵심 정리**  
> readObject() 메서드를 작성할 때는 언제나 public 생성자를 작성하는 자세로 임해야 한다. 넘어오는 바이트 스트림이 진짜 직렬화된 인스턴스라고 가정해서는 안 된다.

### 직렬화의 위험성
불변 클래스를 직렬화하는 경우 더욱 주의를 기울여야 한다. readObject() 메서드는 실질적으로 또 다른 public 생성자이기 때문이다. readObject() 메서드에서도 인수가 유효한지 검사해야 하고, 필요하다면 매개변수를 방어적으로 복사해야 한다. 이 작업을 제대로 수행하지 않으면 공격자는 해당 클래스의 불변식을 깨뜨릴 수 있다.

### 안전한 readObject()를 작성하는 방법
- private이어야 하는 객체 참조 필드는 그 필드가 가리키는 객체를 방어적으로 복사해야 한다. 불변 클래스의 가변 요소가 여기 속한다.
- 모든 불변식을 검사하여 어긋나는게 발견되면 InvalidObjectException을 던진다.
- 역직렬화 후 객체 그래프 전체의 유효성을 검사해야 한다면 ObjectInputValidation 인터페이스를 사용한다.

---

