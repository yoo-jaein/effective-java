# Chapter 08 메서드

## 아이템 49. 매개변수가 유효한지 검사하라 
> **핵심 정리**  
> 메서드나 생성자를 작성할 떄면 그 매개변수들에 어떤 제약이 있을 지 생각해야 한다. 이 습관을 반드시 기르도록 하자. 그 노력은 유효성 검사가 실제 오류를 처음 걸러낼 때 충분히 보상받을 것이다.

메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 메서드 몸체가 실행되기 전에 매개변수의 유효성을 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다. 이 규칙에도 예외는 있다. 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때, 혹은 계산 과정에서 암묵적으로 검사가 수행될 때다. 예를 들어 Collections.sort(List)처럼 객체 리스트를 정렬하는 메서드에서는 정렬 과정에 비교할 수 있는 객체인지 검사하는 로직이 포함되어 있다. 

### 단언문
```java
private static void sort(long a[], int offset, int length) {
	assert a != null;
	assert offset >= 0 && offset <= a.length;
	assert length >= 0 && length <= a.length - offset;
	//... 계산 수행 
}
```
public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다. 단언문은 몇 가지 면에서 일반적인 유효성 검사와 다르다.

- 실패하면 AssertionError를 던진다.
- 런타임에 아무런 효과도 아무런 성능 저하도 없다. (단, java를 실행할 떄 -ea 혹은 --enableassertions 플래그를 설정하면 런타임에 영향을 준다.)

---

## 아이템 50. 적시에 방어적 복사본을 만들라
> **핵심 정리**  
> 클래스가 클라이언트로부터 받는 혹은 클라이언트로 반환하는 요소가 가변이라면 그 요소는 방어적으로 복사하는 것이 좋다.

어떤 객체든 그 객체의 허락 없이는 외부에서 내부를 수정하는 일은 불가능하다. 하지만 주의를 기울이지 않으면 자기도 모르게 내부를 수정하도록 허락하는 경우가 생긴다. 외부 공격으로부터 인스턴스 내부를 보호하려면 생성자에서 받은 가변 매개변수 각각을 방어적으로 복사(defensive copy)해야 한다.

매개변수의 유효성을 검사하기 전에 방어적 복사본을 만들고, 이 복사본으로 유효성을 검사해야 한다. 순서를 지켜야 하는 이유는 멀티스레드 환경이라면 원본 객체의 유효성을 검사한 후 복사본을 만드는 찰나의 취약한 순간에 다른 스레드가 원본 객체를 수정할 위험이 있기 때문이다. 이런 공격을 검사시점/사용시점(time-of-check/time-of-use, TOCTOU) 공격이라 한다.

또한, 매개변수가 확장될 수 있는 타입이라면 방어적 복사본을 만들 때 clone을 사용해서는 안 된다. 공격자에게 접근 경로를 열어줄 수도 있다. 

접근자 메서드(getter)에서도 주의를 기울여야 한다. 접근자가 가변 필드의 정보를 직접 드러내면 안 되고 가변 필드의 방어적 복사본을 반환해야 한다. 이렇게 접근자까지 방어적으로 만들면 자기 자신 말고는 가변 필드에 접근할 방법이 없으니 (네이티브 메서드나 리플렉션 같이 언어 외적인 수단을 제외하고는) 안전하다.  

방어적 복사에는 성능 저하가 따른다. 만약 호출자가 컴포넌트 내부를 수정하지 않으리라 확신하면 방어적 복사를 생략할 수 있다.

---

## 아이템 51. 메서드 시그니처를 신중히 설계하라

### 1. 메서드 이름을 신중히 짓자

표준 명명 규칙을 따르자. 긴 이름은 피하자. 애매하면 자바 라이브러리의 API 가이드를 참조하라.

### 2. 편의 메서드를 너무 많이 만들지 말자

메서드가 너무 많은 클래스는 익히고, 사용하고, 문서화하고, 테스트하고, 유지보수하기 어렵다. 확신이 서지 않으면 만들지 말자.

### 3. 매개변수 목록은 짧게 유지하자

4개 이하가 좋다. 같은 타입의 매개변수 여러 개가 연달아 나오는 경우는 특히 해롭다.

#### 긴 매개변수 목록을 짧게 줄이는 기술
1. 여러 메서드로 쪼갠다. 쪼개진 메서드 각각은 원래 매개변수 목록의 부분집합을 받는다. 잘못하면 메서드가 너무 많아질 수 있지만, 직교성(orthogonality)을 높여 오히려 메서드 수를 줄여주는 효과도 있다. 
2. 매개변수 여러 개를 묶어주는 도우미 클래스를 만든다. 일반적으로 이런 도우미 클래스는 정적 멤버 클래스로 둔다. 잇따른 매개변수 몇 개를 독립된 하나의 개념으로 볼 수 있을 때 추천한다.

### 4. 매개변수의 타입으로는 클래스보다는 인터페이스가 더 낫다

매개변수로 적합한 인터페이스가 있다면 이를 구현한 클래스가 아닌 그 인터페이스를 직접 사용하자. 예를 들어 메서드에 HashMap을 넘기지 말고 Map을 사용하자. 그러면 HashMap뿐 아니라 TreeMap, ConcurrentHashMap 등 어떤 Map 구현체도 인수로 건넬 수 있다. 인터페이스 대신 클래스를 사용하면 클라이언트에게 특정 구현체만 사용하도록 제한하는 꼴이며, 혹시라도 입력 데이터가 다른 형태로 존재한다면 명시한 특정 구현체의 객체로 옮겨 담느라 비싼 복사 비용을 치러야 한다. 

### 5. boolean보다는 원소 2개짜리 열거 타입이 낫다

boolean을 받아야 의미가 더 명확할 때는 예외다. 열거 타입을 사용하면 코드를 읽고 쓰기가 더 쉬워지며 나중에 선택지를 추가하기도 쉽다.

---
