# Chapter 05 제네릭

## 아이템 26. 로 타입은 사용하지 말라
> **핵심 정리**  
> 로 타입은 제네릭이 도입되기 이전 코드와의 호환성을 위해 제공될 뿐이다. 로타입을 사용하면 런타임에 예외가 일어날 수 있으니 사용하면 안 된다. Set<Object>와 Set<?>는 안전하지만, 로 타입인 Set은 안전하지 않다.

### 제네릭
```제네릭(generic)```은 자바 5부터 사용할 수 있다. ```제네릭```을 지원하기 전에는 컬렉션에서 객체를 꺼낼 때마다 형변환을 해야 했다. 만약 누군가 실수로 엉뚱한 타입의 객체를 넣어두면 런타임에 형변환 오류가 나곤 했다. 반면, ```제네릭```을 사용하면 컬렉션이 담을 수 있는 타입을 컴파일러에게 알려주게 되고, 컴파일러가 알아서 형변환 코드를 추가하면서 엉뚱한 타입의 객체를 컴파일 과정에서 차단할 수 있다.  

클래스와 인터페이스 선언에 ```타입 매개변수(type parameter)```가 쓰이면, 이를 ```제네릭 클래스``` 혹은 ```제네릭 인터페이스```라 한다. 이 둘을 통틀어 ```제네릭 타입(generic type)```이라 한다. 각각의 제네릭 타입은 일련의 ```매개변수화 타입(parameterized type)```을 정의한다. 

```java
List<E>
List<String>
```
예를 들어 ```List<String>```은 원소의 타입이 String인 리스트를 뜻하는 ```매개변수화 타입```이다. List<E>의 ```E```는 ```정규 타입 매개변수(formal type parameter)```이고, List<String>의 ```String```은 E의 ```실제 타입 매개변수(actual type paramter)```다.

```java
List
```

제네릭 타입을 하나 정의하면 그에 딸린 ```로 타입(raw type)```도 함께 정의된다. ```로 타입```이란 제네릭 타입에서 타입 매개변수를 사용하지 않을 때를 말한다. List<E>의 로 타입은 ```List```다.

### 제네릭 이전
```java
private final Collection stamps = ...; // Stamp 인스턴스만 취급하는 컬렉션
stamps.add(new Coin(...)); // unchecked call 경고 메시지를 보여주지만 정상적으로 컴파일됨

for (Iterator i = stamps.iterator(); i.hasNext(); ) {
	Stamp stamp = (Stamp) i.next(); // 이 때 런타임에 ClassCastException 발생
	stamp.cancel();
}
```

### 제네릭 코드
```java
private final Collection<Stamp> stamps = ...; // 컴파일러가 stamps에는 Stamp 인스턴스만 넣어야 함을 인지하게 됨
stamps.add(new Coin(...)); // 컴파일 에러가 발생
```

### List<Object>와 List<?>
List<Object>는 모든 타입을 허용한다는 의사를 컴파일러에게 전달한다. List<?>는 ```비한정적 와일드카드 타입(unbounded wildcard type)``` 물음표(?)를 사용하여 제네릭 타입을 사용하고 싶지만 실제 타입 매개변수가 무엇인지 신경 쓰고 싶지 않다는 것을 표현한다. List<?>는 어떤 타입이라도 담을 수 있는 가장 범용적인 매개변수화 List 타입이다.

---

## 아이템 27. 비검사 경고를 제거하라
> **핵심 정리**  
> 모든 비검사 경고는 런타임에 ClassCastException을 일으킬 수 있는 잠재적 가능성을 뜻하기 때문에 가능한 모두 제거해야 한다. 경고를 없앨 수 없다면, 그 코드가 타입 세이프함을 증명하고 가능한 한 범위를 좁혀 @SuppressWarnings("unchecked") 애너테이션으로 경고를 숨겨라.

제네릭을 사용하면 많은 컴파일러 경고를 보게 된다. 비검사(unchecked) 형변환 경고, 비검사 메서드 호출 경고, 비검사 변환 경고 등이다. 할 수 있는 한 모든 ```비검사 경고```를 제거해야 한다. 모두 제거한다면 그 코드는 타입 안정성이 보장된다. 경고를 제거할 수는 없지만 타입 세이프하다고 확신할 수 있다면 ```@SuppressWarnings("unchecked")``` 애너테이션을 달아 경고를 숨기자. 이 애너테이션은 개별 지역변수 선언부터 클래스 전체까지 어떤 선언에도 달 수 있다. 자칫 심각한 경고를 놓칠 수 있으므로 가능한 한 좁은 범위에 적용해야 한다. 

---

## 아이템 28. 배열보다는 리스트를 사용하라
> **핵심 정리**  
> 배열은 공변이고 실체화되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다. 따라서 배열은 런타임에 타입 세이프하지만 컴파일에는 그렇지 않다. 제네릭은 컴파일타임에 타입 세이프하지만 런타임에는 그렇지 않다. 그래서 둘을 섞어 쓰기란 쉽지 않다. 둘을 섞어 쓰다가 컴파일 오류나 경고를 만나면, 배열을 리스트로 대체하는 방법을 적용해보자.

### 배열과 제네릭 타입의 차이
배열과 제네릭 타입에는 중요한 차이가 있다.
1. 배열은 공변(covariant)이지만 제네릭 타입은 불공변(invariant)이다.
2. 배열은 실체화(reify)되지만 제네릭 타입은 타입 정보가 런타임에 소거(erasure)된다.

#### 1. 공변과 불공변
배열은 공변이지만 제네릭 타입은 불공변이라는 것이 무슨 뜻일까? 만약 Integer가 Number의 하위 타입이라고 했을 때, Integer[]는 Number[]가 되며(is-a 관계) Integer[]를 Number[]에 할당하거나 전달할 수 있다. 그러나 List<Number>와 List<Integer>의 관계에서 List<Integer>를 List<Number>에 넘겨줄 수 없다.  

그 이유는 공변 관계가 제네릭이 제공하는 타입 안전성을 깨트릴 수 있기 때문이다. List<Integer>를 List<Number>에 할당한다고 가정해보자.  

```java
List<Integer> integerList = new ArrayList<Integer>();
List<Number> numberList = integerList; // illegal
numberList.add(new Float(3.1415));
```

numberList는 List<Number>이기 때문에 여기에 Float를 추가하는 것은 합법적인 것처럼 보인다. 그러나 numberList에는 integerList가 할당되어 있기 때문에 integerList의 정의에 암시된 Integer 타입 세이프 약속이 깨진다. 이것이 제네릭 타입이 공변이 될 수 없는 이유다. 

#### 2. 실체화와 소거
배열은 실체화되지만 제네릭 타입은 타입 정보가 런타임에 소거된다. 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 체크한다. 그래서 Long 배열에 String을 넣으려 하면 런타임에 ArrayStoreException이 발생한다. 반면, 제네릭은 타입 정보가 런타임에는 소거된다. 원소 타입을 컴파일타임에만 검사하며 런타임에는 알 수 없다는 뜻이다. 

---
## 아이템 29. 이왕이면 제네릭 타입으로 만들라
> **핵심 정리**  
> 클라이언트에서 직접 형변환해야 하는 타입보다 제네릭 타입이 더 안전하고 쓰기 편하다. 

---
## 아이템 30. 이왕이면 제네릭 메서드로 만들라
> **핵심 정리**  
> 클라이언트에서 입력 매개변수와 반환값을 명시적으로 형변환해야 하는 메서드보다 제네릭 메서드가 더 안전하고 쓰기 편하다.
