# Chapter 04 클래스와 인터페이스

## 아이템 15. 클래스와 멤버의 접근 권한을 최소화하라
> **핵심 정리**  
> 꼭 필요한 것만 골라 최소한의 public API를 설계하자. 그 외에는 클래스, 인터페이스, 멤버가 의도치 않게 API로 공개되는 일이 없도록 해야 한다. public 클래스는 상수용 public static final 필드 외에는 어떠한 public 필드도 가져서는 안 된다.

### 접근 수준
- private : 멤버를 선언한 톱레벨 클래스에서만 접근 가능
- package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근 가능. 접근 제한자를 명시하지 않았을 때 적용
- protected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근 가능
- public : 모든 곳에서 접근 가능

### 접근 권한 최소화하기
모든 클래스와 멤버의 접근성을 최소한으로 좁혀야 한다. 그리고 public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다. 단 한 가지 예외는 해당 클래스에 꼭 필요한 구성요소로써 상수용의 public static final 필드다. 관례상 이런 상수의 이름은 대문자 알파벳으로 쓰며, 각 단어 사이에 밑줄(_)을 넣는다. 이 필드는 반드시 기본 타입 값이나 불변 객체를 참조해야 하며, 만약 가변 객체를 참조할 경우 참조된 객체 자체가 수정될 수 있는 위험이 있다.

---

## 아이템 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라
> **핵심 정리**  
> public 클래스는 절대 가변 필드를 직접 노출해서는 안 된다. 불변 필드라면 노출해도 덜 위험하지만 완전히 안심할 수는 없다. 하지만 package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.

### public 필드 대신 private + 접근자 사용하기
```java
class Point {
	public double x;
	public double y;
}
```

위의 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못한다. API를 수정하지 않고는 내부 표현을 바꿀 수 없고, 불변식을 보장할 수 없으며, 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없다.

```java
public final class Time {
	public final int hour;
	public final int minute;
	//...
}
```

public 클래스의 필드가 불변이라면 단점이 조금은 줄어들지만 여전히 결코 좋은 생각이 아니다. API를 변경하지 않고는 표현 방식을 바꿀 수 없고, 여전히 필드를 읽을 때 부수 작업을 수행할 수 없다. 자바 플랫폼 라이브러리의 java.awt.package.Point, Dimension은 public 필드를 직접 노출하여 심각한 성능 문제를 가지고 있다.

```java
class Point {
	private double x;
	private double y;
	
	public Point(doublx x, double y) {
		this.x = x;
		this.y = y;
	}
	
	public double getX() { return x; }
	public double getY() { return y; }
	public void setX(double x) { this.x = x; }
	public void setY(double y) { this.y = y; }
}
```

따라서 필드를 모두 private으로 바꾸고 public 접근자(getter)를 추가한다.  

---

## 아이템 17. 변경 가능성을 최소화하라

```불변 클래스```란 그 인스턴스 내부 값을 수정할 수 없는 클래스다. ```불변 인스턴스```에 간직된 정보는 고정되어 객체가 파괴되는 순간까지 절대 달라지지 않는다. 자바 플랫폼 라이브러리에는 String, 기본 타입의 박싱 클래스들, BigInteger, BigDecimal이 ```불변 클래스```에 속한다. ```불변 클래스```는 ```가변 클래스```보다 설계/구현/사용이 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.  

```게터(getter)```가 있다고 해서 무조건 ```세터(setter)```를 만들지는 말자. 꼭 필요한 경우가 아니라면 모든 필드는 private final로 선언하여 ```불변 클래스```로 만들어야 한다. 불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자. 그리고 생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야 한다.

### 불변 클래스 만들기
클래스를 불변으로 만들려면 다음의 규칙을 따르면 된다.
- 객체의 상태를 변경하는 메서드(변경자, setter)를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다. 하위 클래스에서 부주의하게 객체의 상태를 변경하는 사태를 막는다.
- 모든 필드를 final로 선언한다. 
- 모든 필드를 private으로 선언한다.
- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다. 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.

### 장점
- 불변 객체는 단순하다. 
- 불변 객체는 스레드 세이프하여 동기화할 필요가 없다.
- 불변 객체는 자유롭게 공유할 수 있고, 불변 객체끼리 내부 데이터를 공유할 수 있다.
- 불변 객체는 원자성을 제공한다.

### 상속 막기
```java
public class Complex {
	private final double re;
	private final double im;
	
	private Complex(double re, double im) {
		this.re = re;
		this.im = im;
	}
	
	public static Complex valueOf(double re, double im) {
		return new Complex(re, im);
	}
}
```
```불변 클래스```를 만들려면 자신을 상속하지 못하게 해야 한다. 가장 쉬운 방법은 final 클래스로 선언하는 것이다. 또 다른 방법은 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공하는 것이다.  

---

## 아이템 18. 상속보다는 컴포지션을 사용하라
> **핵심 정리**  
> 상속은 강력하지만 캡슐화를 해친다는 문제가 있다. 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관계일 때만 써야 한다. is-a 관계일 때도 하위 클래스의 패키지가 상위 패키지와 다르고, 상위 클래스가 확장을 고려해 설계되지 않았다면 여전히 문제가 될 수 있다. 상속의 취약점을 피하려면 상속 대신 컴포지션과 포워딩을 사용하자.

### 상속
여기서 말하는 ```상속```은 클래스가 다른 클래스를 확장하는 ```구현 상속```을 말한다. 클래스가 인터페이스를 구현하거나 인터페이스가 다른 인터페이스를 확장하는 ```인터페이스 상속```과는 무관하다.  

```상속```은 ```캡슐화```를 깨뜨린다. 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있다. 상위 클래스의 내부 구현이 변하면, 그 여파로 코드 한 줄 건드리지 않은 하위 클래스가 오동작할 수 있다.

### 컴포지션과 포워딩
상속의 문제를 피하려면 기존 클래스를 확장하는 대신, 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조하도록 만들면 된다. 이러한 설계를 ```컴포지션(composition)```이라 한다. 새 클래스의 인스턴스 메서드들은 기존 클래스의 대응하는 메서드를 호출해 그 결과를 반환하며 이 방식을 ```포워딩(forwarding)```이라 한다. 새 클래스의 메서드들을 ```포워딩 메서드(forwarding method)```라 부른다.

---

## 아이템 19. 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라
> **핵심 정리**  
> 상속용 클래스를 설계하려면 클래스 내부에서 스스로를 어떻게 사용하는지 모두 문서로 남겨야 하며, 문서화된 규칙을 반드시 지켜야 한다. 그러니 클래스를 확장해야 할 명확한 이유가 떠오르지 않으면 상속을 금지하는 편이 낫다. 상속을 금지하려면 클래스를 final로 선언하거나 생성자 모두를 외부에서 접근할 수 없도록 만들면 된다.

상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지 문서로 남겨야 한다.  
그 외의 일반적인 구체 클래스는 상속용으로 설계되지 않았다면 상속을 금지시키는 것이 좋다. 상속을 금지시키려면 클래스를 final로 선언하거나, 모든 생성자를 private 혹은 package-private으로 선언하고 public 정적 팩터리를 만들어주는 방법을 사용하면 된다.

---

## 아이템 20. 추상 클래스보다는 인터페이스를 우선하라
> **핵심 정리**  
> 다중 구현용 타입으로는 인터페이스가 가장 적합하다. 

자바가 제공하는 다중 구현 매커니즘에는 ```인터페이스```와 ```추상 클래스```가 있다. 자바 8부터 인터페이스도 ```디폴트 메서드(default method)```를 제공할 수 있게 되어, 이제는 두 매커니즘 모두 인스턴스 메서드를 구현형태로 제공할 수 있다. 

### 인터페이스
인터페이스는 다음의 특징을 가진다.
- 인터페이스는 인스턴스 필드를 가질 수 없다.
- 인터페이스는 public이 아닌 정적 멤버를 가질 수 없다. (private static 메서드는 예외)

### 믹스인
인터페이스는 ```믹스인(mixin)``` 정의에 안성맞춤이다. ```믹스인```이란 클래스가 구현할 수 있는 타입이다. 예를 들어 Comparable은 자신을 구현한 클래스의 인스턴스들끼리는 순서를 정할 수 있다고 선언하는 ```믹스인 인터페이스```다. 이처럼 대상 타입의 주기능에 선택적 기능을 혼합한다고 해서 ```믹스인```이라 부른다. ```추상 클래스```는 ```믹스인```을 정의할 수 없다. 클래스는 두 ```추상 클래스```를 상속받을 수 없기 때문이다.

### 템플릿 메서드 패턴
```인터페이스```로 타입을 정의하고, 필요하면 ```디폴트 메서드``` 몇 개도 함께 제공한다. 골격을 구현하는 클래스는 나머지 추상 메서드들까지 구현한다. 이렇게 하면 단순히 골격 구현을 확장하는 것만으로 인터페이스를 구현하는 데 필요한 일이 대부분 완료된다.

---

## 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

자바 8 전에는 기존 구현체를 깨뜨리지 않고는 인터페이스에 새로운 메서드를 추가할 방법이 없었다. 인터페이스에 메서드를 추가하면 보통 컴파일 오류가 나는데, 추가된 메서드가 기존 구현체에 이미 존재할 가능성은 아주 낮기 때문이다. 자바 8에서 ```디폴트 메서드```가 등장했지만 위험이 완전히 사라진 것은 아니다. ```디폴트 메서드```는 구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 삽입될 뿐이다.  

흔한 일은 아니지만 ```디폴트 메서드```는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다. 자바 8의 Collection 인터페이스에 추가된 removeIf 메서드때문에 아파치 커먼즈 라이브러리의 SynchronizedCollection 클래스 관련 코드가 수정되는 일이 있었다. 핵심은 인터페이스를 설계할 때는 여전히 세심한 주의를 기울여야 한다는 것이다. ```디폴트 메서드```로 기존 인터페이스에 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.

---

## 아이템 22. 인터페이스는 타입을 정의하는 용도로만 사용하라
> **핵심 정리**  
> 인터페이스는 타입을 정의하는 용도로만 사용해야 한다. 상수 공개용 수단으로 사용하지 말자.

### 상수 인터페이스 안티패턴
```java
public interface PhysicalConstants {
	static final double AVOGADROS_NUMBER = 6.022_140_857e23;
	static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;
}
```
java.io.ObjectStreamConstants 등 자바 플랫폼 라이브러리에도 ```상수 인터페이스```가 몇 개 있으나, 인터페이스를 잘못 활용한 예이니 따라 해서는 안 된다.

### 상수 유틸리티 클래스
```java
public class PhysicalConstants {
	public static final double AVOGADROS_NUMBER = 6.022_140_857e23;
	public static final double BOLTZMANN_CONSTANT = 1.380_648_52e-23;
	
	private PhysicalConstants() { } // 인스턴스화 방지
}
```
상수를 공개할 목적이라면 더 합당한 선택지가 몇 가지 있다.
1. 특정 클래스나 인터페이스와 강하게 연관된 상수라면 그 클래스나 인터페이스 자체에 주가한다.
2. ```열거 타입```으로 나타내기 적합한 상수라면 ```열거 타입```으로 만들어 공개하면 된다.
3. 그것도 아니라면, 인스턴스화할 수 없는 ```유틸리티 클래스```에 담아 공개하자.

---

## 아이템 23. 태그 달린 클래스보다는 클래스 계층구조를 활용하라
> **핵심 정리**  
> 태그 달린 클래스를 써야 하는 상황은 거의 없다. 새로운 클래스를 작성하는 데 태그 필드가 등장한다면 태그를 없애고 계층구조로 대체하는 방법을 생각해보자. 기존 클래스가 태그 필드를 사용하고 있다면 계층구조로 리팩터링하는 걸 고민해보자.

### 태그 달린 클래스
```태그```란 둘 이상의 의미를 표현할 수 있으며 그중 현재 표현하는 의미를 값으로 가지는 필드를 말한다. 
```java
class Figure {
	enum Shape { RECTANGLE, CIRCLE };
	
	final Shape shape; // 태그 - 현재 모양
	
	// RECTANGLE일 때만 쓰이는 필드들
	double length;
	double width;
	
	// CIRCLE일 때만 쓰이는 필드
	double radius;
	
	Figure(double radius) { // 원용 생성자
		this.shape = Shape.CIRCLE;
		this.radius = radius;
	}
	
	Figure(double length, double width) { // 사각형용 생성자
		this.shape = Shape.RECTANGLE;
		this.length = length;
		this.width = width;
	}
	
	double area() {
		switch(shape) {
			case RECTANGLE: return length * width;
			case CIRCLE: return Math.PI * (radius * radius);
			default: throw new AssertionError(shape);
		}
	}
}
```

### 단점
```태그 달린 클래스```에는 단점이 많다.
- 열거 타입 선언, 태그 필드, switch 문 등 쓸데없는 코드가 많다.
- 여러 구현이 한 클래스에 혼합돼 있어서 가독성이 나쁘다.
- 다른 의미를 위한 코드가 언제나 함께하기 때문에 메모리를 많이 사용한다.
- 필드들을 final로 선언하려면 현재 의미에 쓰이지 않는 필드들까지 초기화해야 한다.
- 새로운 의미를 추가할 때마다 모든 switch 문을 찾아서 수정해야 한다.
- 인스턴스의 타입만으로는 현재 나타내는 의미를 알 수 없다.

### 클래스 계층구조
```java
abstract class Figure {
	abstract double area();
}
```

```java
class Circle extends Figure {
	final double radius;
	Circle(double radius) { this.radius = radius; }
	@Override double area() { return Math.PI * (radius * radius); }
}
```

```java
class Rectangle extends Figure {
	final double length;
	final double width;
	Rectangle(double length, double width) { this.length = length; this.width = width; }
	@Override double area() { return length * width; }
}
```

### 클래스 계층구조로 바꾸기
```클래스 계층구조```는 ```태그 달린 클래스```의 단점을 모두 해결한다. ```태그 달린 클래스```를 ```클래스 계층 구조```로 바꾸는 방법은 다음과 같다.
1. 계층구조의 ```루트```가 될 ```추상 클래스```를 정의한다. 
2. 태그 값에 따라 동작이 달라지는 메서드들을 ```루트 클래스```의 ```추상 메서드```로 선언한다. (area 메서드)
3. 태그 값에 상관없이 동작이 일정한 메서드들을 ```루트 클래스```의 ```일반 메서드```로 추가한다.
4. 모든 하위 클래스에서 공통으로 사용하는 필드를 ```루트 클래스```로 올린다.
5. ```루트 클래스```를 확장한 ```구체 클래스```를 의미별로 하나씩 정의한다.
6. ```루트 클래스```가 정의한 ```추상 메서드```를 각 ```구체 클래스```의 의미에 맞게 구현한다.

---

## 아이템 24. 멤버 클래스는 되도록 static으로 만들라
> **핵심 정리**  
> 중첩 클래스에는 네 가지가 있으며 각각의 쓰임이 다르다. 메서드 밖에서도 사용해야 하거나 메서드 안에 정의하기엔 너무 길다면 멤버 클래스. 멤버 클래스의 인스턴스 각각이 바깥 인스턴스를 참조한다면 비정적, 그렇지 않으면 정적으로. 중첩 클래스가 한 메서드 안에서만 쓰이면서 그 인스턴스를 생성하는 지점이 단 한 곳이고 해당 타입으로 쓰기에 적한한 클래스가 이미 있다면 익명 클래스, 그렇지 않으면 지역 클래스로.

### 중첩 클래스
```중첩 클래스(nested class)```란 다른 클래스 안에 정의된 클래스를 말한다. ```중첩 클래스```는 자신을 감싼 바깥 클래스에서만 쓰여야 하며, 그 외의 쓰임새가 있다면 ```톱레벨 클래스```로 만들어야 한다.

### 중첩 클래스의 종류
```중첩 클래스```의 종류는 다음과 같다. 이 중 ```정적 멤버 클래스```를 제외한 나머지는 ```내부 클래스(inner class)```에 해당한다.
- ```정적 멤버 클래스```
- ```(비정적) 멤버 클래스```
- ```익명 클래스```
- ```지역 클래스```

### 정적(static) 멤버 클래스
- 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에 접근할 수 있다.
- private으로 선언하면 바깥 클래스에서만 접근할 수 있다.
- 바깥 인스턴스와 독립적으로 존재할 수 있다.
- 멤버 클래스에서 바깥 인스턴스에 접근할 일이 없다면 정적 멤버 클래스로 만들어야 한다.
- private 정적 멤버 클래스는 바깥 클래스가 표현하는 객체의 한 구성요소를 나타낼 때 쓴다. Map 구현체는 키-값 쌍을 표현하는 Entry 객체들을 가지고 있다. 모든 엔트리가 맵과 연관되어 있지만 엔트리의 메서드들(getKey, getValue, setValue)는 맵을 직접 사용하지 않는다. 따라서 비정적으로 표현하는 것은 낭비다. 비정적으로 표현할 경우 모든 엔트리가 바깥 맵으로의 참조를 갖게 되어 시간과 공간을 낭비할 것이다.

### 비정적(non-static) 멤버 클래스
- 바깥 클래스의 인스턴스와 암묵적으로 연결된다. 바깥 인스턴스 없이는 생성할 수 없다.
- 비정적 멤버 클래스는 바깥 인스턴스로의 숨은 외부 참조를 갖게 된다. 이 참조를 저장하려면 시간과 공간이 소비되며, 가비지 컬렉션이 바깥 클래스의 인스턴스를 수거하지 못하는 메모리 누수가 생길 수 있다.
- 어댑터를 정의할 때 자주 쓰인다. 어떤 클래스의 인스턴스를 감싸 마치 다른 클래스의 인스턴스처럼 보이게 하는 뷰로 사용하는 것이다.

### 익명 클래스
- 이름이 없다.
- 코드의 어디서든 만들 수 있다.
- 바깥 클래스의 멤버가 아니기 때문에 쓰이는 시점에 선언과 동시에 인스턴스가 만들어진다.
- 비정적인 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있다.
- 상수 이외의 정적 멤버를 가질 수 없다. 상수를 위해 초기화된 final 기본 타입과 문자열 필드만 가질 수 있다.
- instanceof 검사나 클래스의 이름이 필요한 작업은 수행할 수 없다.
- 여러 인터페이스를 구현할 수 없고, 인터페이스를 구현하는 동시에 다른 클래스를 상속할 수도 없다.
- 짧지 않으면 가독성이 떨어진다.

### 지역 클래스
- 지역변수를 선언할 수 있는 곳이면 어디서든 선언할 수 있다.
- 유효 범위도 지역변수와 같다.
- 멤버 클래스처럼 이름이 있고 반복해서 사용할 수 있다.
- 비정적인 문맥에서 사용될 때만 바깥 인스턴스를 참조할 수 있다.
- 정적 멤버를 가질 수 없다.
- 짧지 않으면 가독성이 떨어진다.

---

## 아이템 25. 톱레벨 클래스는 한 파일에 하나만 담으라
> **핵심 정리**  
> 소스 파일 하나에는 반드시 톱레벨 클래스(혹은 톱레벨 인터페이스)를 하나만 담자.
