# Chapter 09 일반적인 프로그래밍 원칙

## 아이템 57. 지역변수의 범위를 최소화하라

### 지역변수의 범위 줄이기
```지역변수의 유효 범위```를 최소로 줄이면 코드 가독성과 유지보수성이 높아지고 오류 가능성은 낮아진다. 지역변수의 범위를 줄이는 방법은 다음과 같다.
- 지역변수의 범위를 줄이는 가장 강력한 기법은 ```가장 처음 쓰일 때 선언하기```다. 또한, 거의 모든 지역변수는 ```선언과 동시에 초기화```해야 한다. (try-catch 문은 예외)
- 지역변수의 범위를 줄이는 또 다른 방법은 ```메서드를 작게 유지```하고 ```한 가지 기능에 집중```하는 것이다. 메서드를 기능별로 쪼개자.

### for 문과 while 문
- 컬렉션이나 배열을 순회할 때 ```for-each``` 형태를 쓰자.
- 만약 반복자(iterator)를 사용해야 하는 상황이라면(remove 메서드를 써야 한다든가) f```or-each 문``` 대신 전통적인 ```for 문```을 쓰는게 낫다.
- 또한, 반복 변수의 값을 반복문이 종료된 뒤에도 써야 하는 상황이 아니라면 ```while 문```보다는 ```for 문```을 쓰는 편이 낫다.

---

## 아이템 58. 전통적인 for 문보다는 for-each 문을 사용하라
> **핵심 정리**  
> 전통적인 for 문과 비교했을 때 for-each 문은 명료하고, 유연하고, 버그를 예방해주며 성능 저하도 없다. 가능한 모든 곳에서 for 문이 아닌 for-each 문을 사용하자.

### 전통적인 for 문의 문제
```java
for (Iterator<Suit> i = suits.iterator(); i.hasNext();) {
	for (Iterator<Rank> j = ranks.iterator(); j.hasNext();) {
		deck.add(new Card(i.next(), j.next())); // NoSuchElementException 발생 가능!
	}
}
```

- ```반복자```와 ```인덱스 변수```는 코드를 지저분하게 만든다.
- 위 코드에는 반복문을 중첩할 때 흔히 저지르는 실수가 담겨 있다. 마지막 줄의 i.next()는 숫자(Suit) 하나당 한 번씩만 불려야 하는데, 안쪽 반복문에서 호출되는 바람에 카드(Rank) 하나당 한 번씩 불리고 있다. 만약 숫자가 바닥나면 반복문에서 런타임 예외가 던져질 것이다. 이처럼 잘못된 변수를 사용했을 때 컴파일러가 잡아주리라는 보장이 없다.
- 마지막으로 컬렉션이나 배열이냐에 따라 코드 형태가 상당히 달라지므로 코드 유연성이 떨어진다.

### for-each 문
```java
for (Suit suit : suits) {
	for (Rank rank : ranks) {
		deck.add(new Card(suit, rank));
	}
}
```

```향상된 for 문(enhanced for statement)```인 ```for-each 문```을 사용하면 모든 문제가 자연스럽게 해결된다. 

- ```반복자```와 ```인덱스 변수```를 사용하지 않으니 코드가 깔끔해지고 오류가 날 일이 없다.
- 같은 코드로 컬렉션과 배열을 모두 처리할 수 있다.
- 컬렉션을 중첩해서 순회할 때 ```for 문```보다 코드가 훨씬 간결하다.

```java
public interface Iterable<E> {
	Iterator<E> iterator(); // 이 객체의 원소들을 순회하는 반복자를 반환한다.
}
```

```for-each 문```은 ```Iterable``` 인터페이스를 구현한 객체라면 무엇이든 순회할 수 있다.

### for-each 문을 사용할 수 없는 상황
안타깝게도 ```for-each 문```을 사용할 수 없는 상황이 세 가지 존재한다.
1. ```파괴적인 필터링(destructive filtering)``` : 컬렉션을 순회하면서 선택된 원소를 제거(remove)해야 할 때 사용할 수 없다. 자바 8부터는 Collection.removeIf를 활용할 수 있다.
2. ```변형(transforming)``` : 리스트나 배열을 순회하면서 그 원소의 값 일부 혹은 전체를 교체해야 한다면 리스트의 반복자나 배열의 인덱스를 사용해야 한다.
3. ```병렬 반복(parallel iteration)``` : 여러 컬렉션을 병렬로 순회해야 한다면 각각의 반복자와 인덱스를 사용해 엄격하고 명시적으로 제어해야 한다.

---

## 아이템 59. 라이브러리를 익히고 사용하라
> **핵심 정리**  
> 바퀴를 다시 발명하지 말자. 아주 특별한 나만의 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다. 일반적으로 라이브러리의 코드는 여러분이 직접 작성한 것보다 품질이 좋고, 점차 개선될 가능성이 크다. 개발자 각자가 작성하는 것보다 주목을 훨씬 많이 받으므로 코드 품질도 그만큼 높아진다.

표준 라이브러리를 사용하면 그 코드를 작성한 전문가의 지식과 여러분보다 앞서 사용한 다른 프로그래머들의 경험을 활용할 수 있다. 또한 따로 노력하지 않아도 성능이 지속적으로 개선되며 새로운 기능도 점점 많아진다. 라이브러리가 너무 방대하여 모든 API 문서를 공부하기는 벅차겠지만 자바 프로그래머라면 적어도 ```java.lang```, ```java.util```, ```java.io```와 그 하위 패키지들에는 익숙해져야 한다. ```컬렉션 프레임워크```, ```스트림 라이브러리```, ```java.util.concurrent```도 알아두면 큰 도움이 된다.  

때때로 라이브러리가 여러분에게 필요한 기능을 충분히 제공하지 못할 수 있다. 자바 표준 라이브러리에서 원하는 기능을 찾지 못하면, 고품질의 서드파티 라이브러리를 찾아보자. 구글의 ```guava``` 라이브러리가 대표적이다.

---

## 아이템 60. 정확한 답이 필요하다면 float와 double은 피하라
> **핵심 정리**  
> 정확한 답이 필요한 계산에는 float나 double을 피하라. 코딩 시의 불편함이나 성능 저하를 신경쓰지 않겠다면 BigDecimal을 사용하자. 반면, 성능이 중요하고 소수점을 직접 추적할 수 있고 숫자가 너무 크지 않다면 int나 long을 사용하자. 숫자를 아홉 자리 십진수로 표현할 수 있다면 int, 열여덟 자리 십진수로 표현할 수 있다면 long, 열여덟 자리를 넘어가면 BigDecimal을 사용해야 한다.

```float```와 ```double``` 타입은 ```과학/공학 계산용```으로 설계되었다. ```이진 부동소수점 연산```에 쓰이며, 넓은 범위의 수를 빠르게 정밀한 ```근사치```로 계산하도록 세심하게 설계되었다. 따라서 금융 관련 계산처럼 정확한 결과가 필요할 때는 사용하면 안 된다. 10^(-1), 10^(-2) 등 10의 음의 거듭제곱 수를 표현할 수 없기 때문이다.

### BigDecimal
```java
final BigDecimal TEN_CENTS = new BigDecimal(".10");
int itemsBought = 0;
BigDecimal funds = new BigDecimal("1.00");

for (BigDecimal price = TEN_CENTS; funds.compareTo(price) >= 0; price = price.add(TEN_CENTS)) {
	funds = funds.subtract(price);
	itemsBought++;
}

System.out.println(itemsBought + "개 구입");
System.out.println("잔돈(달러): " + funds);
```

BigDecimal에는 단점이 두 가지 있다. 
1. 기본 타입보다 쓰기가 불편하다. 
2. 기본 타입보다 훨씬 느리다.

### int/long
```java
int itemsBought = 0;
int funds = 100; // 1.00 달러를 100 센트로 변환...

for (int price = 10; funds >= price; price += 10) {
	funds -= price;
	itemsBought++;
}

System.out.println(itemsBought + "개 구입");
System.out.println("잔돈(센트): " + funds);
```

BigDecimal의 대안으로 int 혹은 long 타입을 쓸 수도 있다. 그럴 경우 다룰 수 있는 값의 크기가 제한되고 소수점을 직접 관리해야 한다. 위 예에서는 모든 계산을 달러 대신 센트로 수행하여 문제를 해결했다.

---

## 아이템 61. 박싱된 기본 타입보다는 기본 타입을 사용하라
> **핵심 정리**  
> 가능하면 기본 타입을 사용하라. 기본 타입은 간단하고 빠르다. 박싱된 기본 타입을 써야 한다면 주의를 기울이자. 박싱된 기본 타입 두 개를 == 연산자로 비교한다면 식별성 비교가 이뤄지는데, 이는 여러분이 원한 게 아닐 가능성이 크다. 또한, 같은 연산에서 기본 타입과 박싱된 기본 타입을 혼용하면 언박싱이 이뤄지며, 언박싱 과정에서 NullPointerException을 던질 수 있다. 

자바의 데이터 타입은 크게 두 가지로 나눌 수 있다. int, double, boolean 같은 ```기본 타입(primitive type)```과 String, List 같은 ```참조 타입(reference type)```이다. 각각의 ```기본 타입```에는 대응하는 ```참조 타입```이 하나씩 있으며, 이를 ```박싱된 기본 타입```이라고 한다. 예컨대 int, double, boolean에 대응하는 ```박싱된 기본 타입```은 Integer, Double, Boolean이다.

### 기본 타입과 박싱된 기본 타입의 차이
1. ```기본 타입```은 값만 가지고 있으나, ```박싱된 기본 타입```은 값에 더해 ```식별성(identity)```이란 속성을 갖는다. 박싱된 기본 타입의 두 인스턴스는 값이 같아도 서로 다르다고 식별될 수 있다.
2. ```기본 타입```의 값은 언제나 유효하나, ```박싱된 기본 타입```은 유효하지 않은 값, 즉 ```null```을 가질 수 있다.
3. ```기본 타입```은 ```박싱된 기본 타입```보다 시간과 메모리 사용면에서 더 효율적이다.

### 식별성
```java
Integer a = new Integer(1);
Integer b = new Integer(2);

if (a == b) {
	System.out.println("a와 b는 같다?");
}
```
a == b 검사에서 두 객체 참조의 ```식별성```을 검사한다. a와 b가 서로 다른 Integer 인스턴스이기 때문에 비록 값은 같더라도 이 비교의 결과는 false가 된다. 이처럼 ```박싱된 기본 타입```에 ```== 연산자```를 사용하면 오류가 일어난다.

### null 참조의 위험
```java
Integer a;

if (a == 42) {
	System.out.println("NPE가 발생한다.");
}
```

a == 42 검사에서 NullPointerException이 발생한다. a와 int 42를 비교하는 과정에서 ```null 참조(초깃값)```를 ```언박싱```하게 되어 예외가 발생하는 것이다.

### 성능 문제
```java
Long sum = 0;
for (long i = 0; i <= Integer.MAX_VALUE; i++) {
	sum += i;
}
System.out.println(sum);
```

이 프로그램은 지역변수 sum을 ```박싱된 기본 타입``` Long으로 선언하여 느려졌다. 오류나 경고 없이 컴파일되지만 반복 로직에서 ```박싱```과 ```언박싱```이 반복해서 일어나면서 심각한 성능 문제가 있다.

### 박싱된 기본 타입을 사용해야 할 때
```박싱된 기본 타입```이 적절히 쓰이는 경우가 몇 가지 있다.
1. 컬렉션의 원소, 키, 값으로 쓴다. 컬렉션은 ```기본 타입```을 담을 수 없으므로 ```박싱된 기본 타입```을 써야만 한다. 더 일반화해 말하면, ```매개변수화 타입```이나 ```매개변수화 메서드의 타입 매개변수```로 ```박싱된 기본 타입```을 써야 한다.
2. 리플렉션을 통해 메서드를 호출할 때 쓴다.

---

## 아이템 62. 다른 타입이 적절하다면 문자열 사용을 피하라
> **핵심 정리**  
> 적합한 테이터 타입이 있으면 문자열을 쓰지 마라. 

```문자열(String)```은 다른 값 타입을 대신하기에 적절하지 않다. int, float, BigInteger, boolean, 열거 타입, 혼합 타입 등 적절한 데이터 타입을 선택해야 한다.

---

## 아이템 63. 문자열 연결은 느리니 주의하라
> **핵심 정리**  
> 성능에 신경 써야 한다면 많은 문자열을 연결할 때는 문자열 연결 연산자(+)를 피하자. 대신 StringBuilder의 append 메서드를 사용하라.

```문자열 연결 연산자(+)```는 여러 문자열을 하나로 합쳐준다. 크기가 작고 고정된 문자열 표현을 만들 때라면 괜찮지만, 본격적으로 사용하기 시작하면 성능 저하를 감내하기 어렵다. 문자열 연결 연산자로 ```문자열 n개```를 잇는 시간은 ```n^2```에 비례하기 때문이다. 문자열은 ```불변```이라서 두 문자열을 연결할 경우 양쪽의 내용을 모두 복사해야 하므로 성능 저하는 피할 수 없다.

```java
String result = "";
for (int i = 0; i < numItems(); i++)
	result += lineForItem(i); // 문자열 연결
return result;
```

품목이 많을 경우 이 메서드는 심각하게 느려질 수 있다. 따라서 String 대신 ```StringBuilder```를 사용하자.

```java
StringBuilder sb = new StringBuilder(numItems() * LINE_WIDTH);
for (int i = 0; i< numItems(); i++)
	sb.append(lineForItem(i));
return sb.toString();
```

---

## 아이템 64. 객체는 인터페이스를 사용해 참조하라

```java
// 좋은 예
Set<Fruit> set = new LinkedHashSet<>();
List<Fruit> list = new ArrayList<>();
```

```java
// 나쁜 예
LinkedHashSet<Fruit> badSet = new LinkedHashSet<>();
ArrayList<Fruit> badList = new ArrayList<>();
```

적합한 ```인터페이스```만 있다면 ```매개변수```뿐 아니라 ```반환값```, ```변수```, ```필드```를 전부 ```인터페이스 타입```으로 선언하라. 객체의 ```실제 클래스```를 사용해야 할 상황은 '오직' ```생성자```로 생성할 때뿐이다. 적절한 ```인터페이스```를 참조하면 더 유연하고 세련된 프로그램을 만들 수 있다. 나중에 ```구현 클래스```를 교체하고자 한다면 새 클래스의 생성자를 호출해주기만 하면 된다.  

단, 주의할 점이 하나 있다. 원래의 클래스가 인터페이스의 일반 규약 이외의 특별한 기능을 제공하며, 기존 코드가 이 기능에 의존해 동작한다면 교체한 클래스도 반드시 같은 기능을 제공해야 한다.  

만약 적합한 인터페이스가 없다면 당연히 클래스로 참조해야 한다. 그래도 가능한 클래스의 계층구조 중 필요한 기능을 만족하는 ```가장 상위의 클래스```를 타입으로 사용하자.  

---

## 아이템 65. 리플렉션보다는 인터페이스를 사용하라
> **핵심 정리**  
> 리플렉션은 복잡한 특수 시스템을 개발할 때 필요한 강력한 기능이지만, 단점도 많다.

리플렉션 기능(java.lang.reflect)을 이용하면 프로그램에서 임의의 클래스에 접근할 수 있다. Class 객체가 주어지면 그 클래스의 생성자, 메서드, 필드에 해당하는 Constructor, Method, Field 인스턴스를 가져올 수 있고, 이 인스턴스들로 멤버 이름, 필드 타입, 메서드 시그니처 등을 가져올 수 있다. 더 나아가 각각에 연결된 실제 생성자, 메서드, 필드를 조작할 수도 있다. 물론 단점이 있다.

- 컴파일타임 타입 검사가 주는 이점을 하나도 누릴 수 없다. 리플렉션을 통해 존재하지 않는 메서드를 호출하려 시도하면 런타임 오류가 발생한다.
- 코드가 지저분해진다.
- 성능이 떨어진다.

코드 분석 도구나 의존관계 주입 프레임워크처럼 리플렉션을 써야 하는 복잡한 애플리케이션이 몇 가지 있다. 리플렉션은 이렇게 아주 제한된 형태로만 사용해야 하며, 대부분의 애플리케이션에서 리플렉션이 필요한지 확신할 수 없다면 아마도 필요 없을 가능성이 크다.

---

## 아이템 66. 네이티브 메서드는 신중히 사용하라
> **핵심 정리**  
> 네이티브 메서드를 사용하려거든 한번 더 생각하라. 네이티브 메서드가 성능을 개선해주는 일은 많지 않다. 최소한만 사용하고 철저히 테스트하라. 네이티브 코드 안에 숨은 단 하나의 버그가 여러분 애플리케이션 전체를 훼손할 수도 있다.

```자바 네이티브 인터페이스(Java Native Interface, JNI)```는 자바 프로그램이 ```네이티브 메서드```를 호출하는 기술이다. ```네이티브 메서드```란 ```C```나 ```C++``` 같은 ```네이티브 프로그래밍 언어```로 작성한 메서드를 말한다. ```네이티브 메서드```의 주요 쓰임은 다음 세 가지다.
1. 레지스트리 같은 ```플랫폼 특화``` 기능을 사용한다.
2. 네이티브 코드로 작성된 ```기존 (레거시) 라이브러리```를 사용한다.
3. ```성능 개선```을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성한다.

그러나 성능을 개선할 목적으로 ```네이티브 메서드```를 사용하는 것은 거의 권장하지 않는다. ```네이티브 메서드```에는 심각한 단점이 있다.
1. 네이티브 언어가 안전하지 않으므로 ```네이티브 메서드```를 사용하는 애플리케이션도 메모리 훼손 오류로부터 안전하지 않다.
2. 플랫폼을 많이 타서 이식성도 낮다.
3. 디버깅이 어렵다.
4. 주의하지 않으면 속도가 오히려 느려질 수 있다.
5. 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하고, 심지어 추적도 할 수 없다.
6. 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용이 추가된다.
7. 네이티브 메서드와 자바 코드 사이의 접착 코드(glue code)를 작성해야 한다.

---

## 아이템 67. 최적화는 신중히 하라
> **핵심 정리**  
> 빠른 프로그램을 작성하려 안달하지 말자. 좋은 프로그램을 작성하다 보면 성능은 따라오기 마련이다. 하지만 API, 네트워크 프로토콜, 영구 저장용 데이터 포맥을 설계할 때는 성능을 염두에 두어야 한다. 

```text
최적화를 할 때는 다음 두 규칙을 따르라.
첫 번째, 하지 마라.
두 번째, 아직 하지 마라. 
- M. A. 잭슨
```

빠른 프로그램보다는 좋은 프로그램을 작성하라. 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있따. 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다.  

프로그램을 완성할 때까지 성능 문제를 무시하라는 뜻이 아니다. 설계 단계에서 성능을 반드시 염두에 두어야 한다. 완성 후 변경하기가 가장 어려운 설계 요소는 컴포넌트끼리의 소통 방식과 외부 시스템과의 소통 방식이다. API, 네트워크 프로토콜, 데이터베이스에 저장할 데이터 포맷 등이 대표적이다. 이런 설계 요소들은 완성 후에는 변경하기 어렵거나 불가능할 수 있으며, 동시에 시스템 성능을 심각하게 제한할 수 있다. 

---

## 아이템 68. 일반적으로 통용되는 명명 규칙을 따르라

자바의 명명 규칙은 철자 규칙과 문법 규칙으로 나뉜다.

### 철자 규칙
철자 규칙은 패키지, 클래스, 인터페이스, 메서드, 필드, 타입 변수의 이름을 다룬다.
- 패키지와 모듈 이름은 각 요소를 점(.)으로 구분하여 계층적으로 짓는다. 모두 소문자 알파벳 혹은 숫자로 이뤄진다.
- 패키지와 모듈 이름은 조직의 인터넷 도메인 이름을 역순으로 사용한다. 예외적으로 표준 라이브러리와 선택적 패키지들은 각각 java, javax로 시작한다.
- 패키지 요소의 이름은 일반적으로 8자 이하의 짧은 단어로 한다. 
- 클래스와 인터페이스의 이름은 하나 이상의 단어로 이뤄진다. 각 단어는 대문자로 시작하며 널리 통용되는 줄임말을 제외하고는 단어를 줄여 쓰지 않돌고 한다.
- 메서드와 필드 이름은 첫 글자를 소문자로 쓴다는 점만 빼면 클래스 명명 규칙과 같다.
- 불변 static final 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 밑줄(_)로 구분한다.
- 타입 매개변수의 이름은 보통 한 문자로 표현한다.
  - 임의의 타입엔 T
  - 컬렉션 원소의 타입은 E
  - 맵의 키와 값에는 K와 V
  - 예외에는 X
  - 메서드의 반환 타입에는 R
  - 임의 타입의 시퀀스에는 T, U, V 혹은 T1, T2, T3

### 문법 규칙
- 객체를 생성할 수 있는 클래스의 이름은 단수 명사나 명사구를 사용한다.
- 객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사로 짓는다.
- 인터페이스 이름은 클래스와 똑같이 짓거나 able 혹은 ible로 끝나는 형용사로 짓는다.
- 동작을 수행하는 메서드의 이름은 동사나 목적어를 포함한 동사구로 짓는다.
- boolean 값을 반환하는 메서드라면 보통 is나 has로 시작하고 아무 단어나 구로 끝난다.
- 그 외 메서드의 이름은 명사, 명사구 혹은 get으로 시작하는 동사구로 짓는다.
- 객체의 타입을 바꿔서 다른 타입의 객체를 반환하는 인스턴스 메서드의 이름은 toType 형태로 짓는다.
- 객체의 내용을 다른 뷰로 보여주는 메서드의 이름은 asType 형태로 짓는다.
- 객체의 값을 기본 타입 값으로 반환하는 메서드의 이름은 typeValue 형태로 짓는다. 
- 정적 팩터리의 이름은 다양하지만 from, of, valueOf, instance, getInstance, newInstance, getType, newType을 흔히 사용한다.
- boolean 타입 필드 이름은 보통 boolean 접근자 메서드에서 앞 단어를 뺀 형태다.
- 다른 타입의 필드라면 명사나 명사구를 사용한다.

