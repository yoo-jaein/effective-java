# Chapter 10 예외

## 아이템 69. 예외는 진짜 예외 상황에만 사용하라 
> **핵심 정리**  
> 예외는 예외 상황에서 쓸 의도로 설계되었다. 정상적인 제어 흐름에서 사용해서는 안 된다.

```예외```는 ```예외 상황```에 쓸 용도로 설계되었다. 절대로 일상적인 제어 흐름용으로 쓰여선 안 된다. 성능 개선을 목적으로 과하게 쓰는 것도 자제하라. 실제로 성능이 좋아지더라도 자바 플랫폼이 꾸준히 개선되고 있으니 최적화로 얻은 성능 우위가 오래가지 않을 수 있다. 

---

## 아이템 70. 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
> **핵심 정리**  
> 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자. 검사 예외도 아니고 런타임 예외도 아닌 throwable은 정의하지도 말자. 

자바는 문제 상황을 알리는 타입(throwable)으로 ```검사 예외```, ```런타임 예외```, ```에러```, 이렇게 세 가지를 제공한다. [참고](https://github.com/yoo-jaein/TIL/blob/main/Spring/Error_and_Exception.md)  

- 호출하는 쪽에서 복구하리라 여겨지는 상황이라면 ```검사 예외```를 사용하자.
- 프로그래밍 오류는 ```런타임 예외```를 사용하자.
- 여러분이 구현하는 ```비검사 예외```는 모두 ```RuntimeException```의 하위 클래스여야 한다.
- ```JVM```이 자원 부족 등으로 더 이상 수행을 계속할 수 없을 때 ```에러```가 사용된다. ```에러(Error)```는 상속하지 말아야 할 뿐 아니라, throw 문으로 직접 던지는 일도 없어야 한다. (AssertionError 제외)
- ```Exception```, ```RuntimeException```, ```Error```를 상속하지 않는 ```throwable```을 만들 수도 있지만 절대로 사용하지 말자.
- 예외도 클래스이므로 예외를 일으킨 상황에 관한 정보를 전달할 수 있는 메서드를 만드는 것도 좋다. 

---

## 아이템 71. 필요 없는 검사 예외 사용은 피하라
> **핵심 정리**  
> 꼭 필요한 곳에만 사용한다면 검사 예외는 프로그램의 안전성을 높여주지만, 남용하면 쓰기 고통스러운 API를 낳는다. API 호출자가 예외 상황에서 복구할 방법이 없다면 비검사 예외를 던지자. 복구가 가능하고 호출자가 그 처리를 해주길 바란다면, 우선 옵셔널을 반환해도 될지 고민하자. 옵셔널만으로는 상황을 처리하기에 충분한 정보를 제공할 수 없을 때만 검사 예외를 던지자.

어떤 메서드가 ```검사 예외```를 던질 수 있다고 선언됐다면, 이를 호출하는 코드에서는 ```catch``` 블록을 두어 그 예외를 붙잡아 처리하거나 더 바깥으로 던져 문제를 전파해야만 한다. 어느 쪽이든 API 사용자에게 부담을 준다. 더구나 ```검사 예외```를 던지는 메서드는 스트림 안에서 직접 사용할 수 없기 때문에 자바 8부터는 부담이 더욱 커졌다.  

### 검사 예외 안 던지기
따라서 ```검사 예외```를 반드시 써야 할 상황이 아니라면 검사 예외를 안 던지는 방법이 있는지 고민해볼 가치가 있다. ```검사 예외```를 회피하는 방법에는 두 가지가 있다.  
1. 적절한 결과 타입을 담은 옵셔널을 반환한다. 이 방식의 단점은 예외가 발생한 이유를 알려주는 부가 정보를 담을 수 없다는 것이다.
2. ````검사 예외````를 던지는 메서드를 상태 검사 메서드와 비검사 예외를 던지는 메서드 2개로 쪼개 비검사 예외로 바꿀 수 있다.

---

## 아이템 72. 표준 예외를 사용하라

코드와 마찬가지로 예외도 재사용하는 것이 좋다. 자바 라이브러리는 대다수의 API에서 쓰기에 적절한 ```표준 예외```들을 제공한다. 여러분의 API에 ```표준 예외```를 사용하면 많은 프로그래머에게 이미 익숙한 규약을 그대로 따르기 때문에 다른 사람이 익히고 사용하기 쉬워진다.  

```표준 예외```를 재사용할때는 API 문서를 참고해 그 예외가 어떤 상황에서 던져지는지 꼭 확인해야 한다. 예외의 이름뿐 아니라 예외가 던져지는 맥락도 부합할 때만 재사용한다.  

### 자주 재사용되는 표준 예외
1. ```IllegalArgumentException``` : 호출자가 인수로 부적절한 값을 넘길 때 던지는 예외. 반복 횟수를 지정하는 매개변수에 음수를 건낼 때.
2. ```IllegalStateException``` : 대상 객체의 상태가 호출된 메서드를 수행하기에 적절하지 않은 상태일 때 던지는 예외. 제대로 초기화되지 않은 객체를 사용하려 할 때.
3. ```NullPointerException``` : null 값을 허용하지 않는 메서드에 null을 건낼 때 던지는 예외.
4. ```IndexOutOfBoundsException``` : 어떤 시퀀스의 허용 범위를 넘는 값을 건낼 때 던지는 예외.
5. ```ConcurrentModificationException``` : 단일 스레드에서 사용하려고 설계한 객체를 여러 스레드가 동시에 수정하려 할 때 던지는 예외.
6. ```UnsupportedOperationException``` : 클라이언트가 요청한 동작을 대상 객체가 지원하지 않을 때 던지는 예외. 
7. ```ArithmeticException``` 
8. ```NumberFormatException```  

---

## 아이템 73. 추상화 수준에 맞는 예외를 던지라
> **핵심 정리**  
> 저수준의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이때 예외 연쇄를 이용하면 상위 계층에 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.

상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다. 이를 ```예외 번역(exception translation)```이라 한다. 

### 예외 번역
```java
public E get(int index) {
	try {
		return listIterator(index).next();
	} catch (NoSuchElementException exc) {
		throw new IndexOutOfBoundsException("Index: "+index);
	}
}
```
위 코드는 AbstractSequentialList에서 수행하는 예외 번역의 예다. AbstractSequentialList는 List 인터페이스의 골격 구현이다. 이 예에서 수행한 예외 번역은 List<E> 인터페이스의 get 메서드 명세에 명시된 필수 사항이다.  

### 예외 연쇄
```java
class HigherLevelException extends Exception {
	HigherLevelException(Throwable cause) {
		super(cause);
	}
}
```
예외를 번역할 때, ```저수준 예외```가 디버깅에 도움이 된다면 ```예외 연쇄(exception chaining)```를 사용하는 게 좋다. ```예외 연쇄```란 ```문제의 근본 원인(cause)```인 ```저수준 예외```를 ```고수준 예외```에 실어 보내는 방식이다. 그러면 별도의 접근자 메서드(Throwable의 getCause())를 통해 필요하면 언제든 ```저수준 예외```를 꺼내 볼 수 있다. 대부분의 ```표준 예외```는 예외 연쇄를 위한 생성자를 갖추고 있다.

---

## 아이템 74. 메서드가 던지는 모든 예외를 문서화하라
> **핵심 정리**  
> 메서드가 던질 가능성이 있는 모든 예외를 문서화하라. 문서화에는 자바독의 @throws 태그를 사용하면 된다. 메서드 선언의 throws 문에 검사 예외만 선언하고, 비검사 예외는 기입하지 말자. 

```검사 예외```는 항상 따로따로 선언하고, 각 예외가 발생하는 상황을 자바독의 ```@throws``` 태그를 사용하여 정확히 문서화하자. 공통 상위 클래스(Exception이나 Throwable) 하나로 뭉뚱그려 선언하는 일은 삼가자. 이 경우 메서드 사용자에게 각 예외에 대처할 수 있는 힌트를 주지 못 한다.  

다만 ```비검사 예외```는 메서드 선언의 ```throws``` 목록에 넣지 말자. 검사냐 비검사냐에 따라 API 사용자가 해야 할 일이 달라지므로 이 둘을 확실히 구분해주는 게 좋다. 

---

## 아이템 75. 예외의 상세 메시지에 실패 관련 정보를 담으라

### 스택 트레이스
```java
public class HelloWorld {
	public static void main(String[] args) {
		print();
	}

	public static void print() {
		int[] arr = new int[]{1,2,3};
		System.out.println("arr[4] = " + arr[4]);
	}
}
```
```text
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length 3
	at chap07.HelloWorld.print(HelloWorld.java:10)
	at chap07.HelloWorld.main(HelloWorld.java:5)
```
예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 ```스택 추적(stack trace)``` 정보를 자동으로 출력한다. ```스택 트레이스```는 예외 객체의 ```toString``` 메서드를 호출해 얻는 문자열로, 보통은 예외 클래스 이름 뒤에 상세 메시지가 붙는 형태다.  

```스택 트레이스``` 정보는 ```실패 원인```에 관한 정보를 가능한 한 많이 담아야 한다. 따라서 모든 ```매개변수```와 ```필드```의 값을 실패 메시지에 담아야 한다. 예컨대 ArrayIndexOutOfBoundsException의 상세 메시지는 배열의 길이와 그 범위를 벗어났다는 인덱스의 값을 담아야 한다. 이 정보는 실패에 관한 많은 것을 알려주므로 무엇을 고쳐야 할지를 찾는 데 큰 도움이 된다.  

```java
public IndexOutOfBoundsException(int lowerBound, int upperBound, int index) {
	super(String.format("min: %d, max: %d, index: %d", lowerBound, upperBound, index));
	//...
}
```
실패를 적절히 포착하려면 필요한 정보를 예외 생성자에서 모두 받아서 상세 메시지까지 미리 생성해놓는 방법도 괜찮다. 이렇게 해두면 프로그래머가 던지는 예외는 자연스럽게 실패를 더 잘 포착한다. 또한 고품질의 상세 메시지를 만들어내는 코드를 예외 클래스 안으로 모아주는 효과도 있어, 클래스 사용자가 메시지를 만드는 작업을 중복하지 않아도 된다. 예외 클래스에서 실패와 관련된 정보를 얻을 수 있는 접근자 메서드(lowerBound, upperBound, index 정도)를 적절히 제공하는 것도 좋다.

참고로 예외의 상세 메시지와 최종 사용자(end user)에게 보여줄 오류 메시지를 혼동해서는 안 된다. 최종 사용자에게는 친절한 안내 문구를 보여줘야 하는 반면, 예외 메시지는 가독성보다는 담긴 내용이 훨씬 중요하다.  

---

## 아이템 76. 가능한 한 실패 원자적으로 만들라
호출된 메서드가 중간에 실패하더라도 해당 객체는 메서드 호출 전의 상태를 유지해야 한다는 특성을 ```실패 원자성(failure-atomic)```이라 한다. ```실패 원자성```을 얻는 방법은 다음과 같다.

1. 불변 객체 사용하기
2. 가변 객체의 경우 작업 수행 전에 매개변수의 유효성을 검사하기
3. 실패 가능성이 있는 모든 코드를 객체의 상태를 바꾸는 코드보다 앞에 배치하기
4. 객체의 임시 복사본을 만들고 복사본에서 작업을 수행한 다음, 작업이 성공적으로 완료되면 원래 객체와 교체하기
5. 작업 도중 발생하는 실패를 가로채는 복구 코드를 작성하고 해당 코드에서 작업 전 상태로 되돌리기

참고로 실패 원자성은 일반적으로 권장되는 덕목이지만 항상 달성할 수 있는 것은 아니다. 

---

## 아이템 77. 예외를 무시하지 말라

```java
try {
	//...
} catch (SomeException e) {}
```

```catch``` 블록을 비워두면 예외가 무시된다. 예외는 문제 상황에 잘 대처하기 위해 존재하는데 ```catch``` 블록을 비워두면 예외가 존재할 이유가 없어진다. 따라서 빈 catch 블록을 보면 예외에 대해 적절한 조치를 취해줘야 한다.  

```java
try {
	//...
} catch (SomeException ignored) {
	// 기본 값을 사용한다.
}
```
만약 예외를 무시하기로 결정했다면 ```catch``` 블록 안에 그렇게 결정한 이유를 주석으로 남기고, 예외 변수의 이름도 ```ignored```로 바꿔놓도록 하자.
